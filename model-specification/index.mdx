---
title: "Model Specification"
description: "Define probabilistic models for BCI applications using Nimbus's declarative syntax"
icon: "code"
---

# Model Specification for BCI

Nimbus uses a declarative model specification syntax inspired by probabilistic programming languages. This approach allows you to define complex BCI models by specifying relationships between neural signals, brain states, and control outputs in an intuitive, mathematical notation.

## The @model Syntax

Nimbus models are defined using the `@model` decorator, which converts your model specification into an optimized factor graph for real-time inference.

```python
@model
def bci_decoder(neural_signals, movement_intent, noise_variance):
    # Prior over intended movement
    movement_intent[0] ~ Normal(mean=0.0, variance=1.0)
    
    # Neural signal observations
    neural_signals[0] ~ Normal(mean=movement_intent[0], variance=noise_variance)
    
    # Temporal dynamics
    for t in range(1, len(neural_signals)):
        movement_intent[t] ~ Normal(
            mean=movement_intent[t-1], 
            variance=0.1
        )
        neural_signals[t] ~ Normal(
            mean=movement_intent[t], 
            variance=noise_variance
        )
```

<Card title="Key Benefits" icon="star">
  **Declarative**: Specify what the model should represent, not how to compute it
  
  **Automatic Optimization**: Nimbus automatically generates efficient message passing algorithms
  
  **Real-time Ready**: Models compile to sub-20ms inference pipelines
</Card>

## BCI Model Components

### Neural Signal Processing

Model the relationship between raw neural recordings and underlying brain states:

```python
@model
def neural_encoder(raw_signals, brain_state, electrode_noise):
    # Multiple electrode channels
    for channel in range(num_channels):
        raw_signals[channel] ~ Normal(
            mean=brain_state * channel_weights[channel],
            variance=electrode_noise[channel]
        )
```

### Temporal Dynamics

Capture how brain states evolve over time:

```python
@model
def temporal_dynamics(brain_states, transition_noise):
    # Initial state prior
    brain_states[0] ~ Normal(mean=0.0, variance=10.0)
    
    # State transitions with momentum
    for t in range(1, sequence_length):
        brain_states[t] ~ Normal(
            mean=0.9 * brain_states[t-1],  # Momentum factor
            variance=transition_noise
        )
```

### Control Output Mapping

Map inferred brain states to control commands:

```python
@model
def control_mapper(brain_state, control_output, mapping_uncertainty):
    # Nonlinear mapping with uncertainty
    control_output ~ Normal(
        mean=sigmoid(brain_state),
        variance=mapping_uncertainty
    )
```

## Model Composition

Combine multiple model components for complex BCI systems:

<CardGroup cols={2}>
  <Card title="Hierarchical Models" icon="layers">
    Build multi-level models from simple components
  </Card>
  <Card title="Modular Design" icon="cubes">
    Reuse model components across different BCI applications
  </Card>
  <Card title="Adaptive Structure" icon="refresh">
    Models that adapt their structure based on user performance
  </Card>
  <Card title="Multi-modal Integration" icon="signal">
    Combine EEG, EMG, and other sensor modalities
  </Card>
</CardGroup>

## Hyperparameters and Configuration

### Static Parameters

Define fixed model parameters that don't change during inference:

```python
model = bci_decoder(
    noise_variance=0.1,
    num_channels=64,
    sampling_rate=1000
)
```

### Adaptive Parameters

Parameters that update based on user performance or environmental conditions:

```python
@model
def adaptive_bci(signals, performance_feedback):
    # Noise variance adapts based on signal quality
    noise_variance ~ Gamma(alpha=2.0, beta=1.0)
    
    # Update based on feedback
    noise_variance = update_noise_estimate(
        noise_variance, 
        performance_feedback
    )
```

## Data Conditioning

### Real-time Data Streams

Connect your model to live neural data:

```python
# Create model generator
model = bci_decoder(noise_variance=0.1)

# Condition on streaming data
conditioned_model = model | {
    'neural_signals': StreamingDataHandler(),
    'movement_intent': InferenceTarget()
}
```

### Batch Processing

For offline analysis and model training:

```python
# Historical data conditioning
training_data = {
    'neural_signals': recorded_eeg_data,
    'movement_intent': ground_truth_labels
}

conditioned_model = model | training_data
```

## Advanced Features

### Non-conjugate Inference

Handle complex, non-linear relationships in BCI models:

```python
@model
def nonlinear_bci(neural_signals, brain_state):
    # Nonlinear observation model
    neural_signals ~ CustomDistribution(
        transform=neural_network_transform,
        input=brain_state
    )
```

### Multi-subject Models

Build models that work across different users:

```python
@model
def multi_subject_bci(signals, subject_id, population_params):
    # Subject-specific parameters
    subject_params ~ Normal(
        mean=population_params[subject_id],
        variance=individual_variance
    )
    
    # Subject-adapted observations
    signals ~ Normal(
        mean=subject_params * brain_state,
        variance=measurement_noise
    )
```

## Performance Optimization

### Model Compilation

Nimbus automatically optimizes your models for real-time performance:

- **Graph Simplification**: Removes redundant computations
- **Message Caching**: Reuses intermediate results
- **Parallel Processing**: Leverages multi-core and GPU acceleration
- **Memory Management**: Minimizes allocation overhead

### Profiling and Debugging

<CardGroup cols={2}>
  <Card title="Inference Profiler" icon="chart-bar" href="/development/testing-validation">
    Analyze computational bottlenecks in your models
  </Card>
  <Card title="Model Visualization" icon="eye" href="/development/custom-nodes">
    Visualize factor graphs and message flow
  </Card>
</CardGroup>

## Next Steps

<CardGroup cols={2}>
  <Card title="BCI Model Examples" icon="play" href="/model-specification/bci-examples">
    Explore pre-built models for common BCI applications
  </Card>
  <Card title="Custom Node Development" icon="cog" href="/development/custom-nodes">
    Create specialized nodes for your BCI hardware
  </Card>
  <Card title="Real-time Deployment" icon="clock" href="/inference-configuration/real-time-setup">
    Deploy your models for live BCI control
  </Card>
  <Card title="API Reference" icon="book" href="/api-reference/inference-endpoints">
    Detailed API documentation for model specification
  </Card>
</CardGroup>
